<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[利用github创建静态项目展示页]]></title>
      <url>%2F2016%2F12%2F09%2Fgithub-pages%2F</url>
      <content type="text"><![CDATA[最近在做期末一个小作业，6个前端展示页，于是就想到了放到github上为了更方便的访问于是就有了这篇文章。 准备工作 注册github账号 创建一个公有项目 下载安装git 至此准备工作做好，这些都是基本的步奏，由于本篇文章重点不在此，所以就不再赘述。如果想学习git的使用，推荐廖雪峰的github教程廖雪峰的官方网站; 初始化项目在本地新建project项目文件夹，并初始化：123mkdir project &amp;&amp; projectcd projectgit init 关联刚才创建的远程仓库。注意这里要换成你自己远程库地址1git remote add origin git@github.com:insertsweat/project.git 创建gh-pages分支，并推送项目写好你的项目之后将新建一个文件夹用于存放你的展示页，并push12mkdir view &amp;&amp; viewpush subtree push --prefix=view origin gh-pages 其中view就是你展示的文件夹 然后打开访问地址就是1https://insertsweat.github.io/project //github用户名.github.io/项目名 如果有问题欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript模块化编程]]></title>
      <url>%2F2016%2F12%2F03%2Fjs-module%2F</url>
      <content type="text"><![CDATA[立即执行函数写发不暴露私有变量12345678910111213141516var module1=(function()&#123; var _count=0; var m1=function()&#123; //todo &#125; var m2=function()&#123; //todo &#125; return &#123; m1:m2, m2:m2 &#125;&#125;)(); 放大模式继承另一个模块123456var module1=(function(mod)&#123; mod.m3=function()&#123; //..todo &#125; return mod;&#125;)(module1) 为module1模块增加了一个新方法m3()，再放回新的module1模块 宽放大模式在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。12345var module1=(function(mod)&#123; //..todo return mod;&#125;)(window.module1||&#123;&#125;); 输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。123var module1=(function($,yui)&#123; //..todo&#125;)(jQuery,YAHOO);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS创建对象的几种方法]]></title>
      <url>%2F2016%2F11%2F22%2Fjs-create-object%2F</url>
      <content type="text"><![CDATA[工厂模式由于考虑到ECMAScript中无法创建类，所以开发人员发明了一种函数，用函数来封装以特定接口来创建对象的细节，如下；12345678910function createPerson(name,age)&#123; var o=new Object(); o.name=name; o.age=age; o.sayName=function()&#123; console.log(this.name); &#125; return o;&#125;var person=createPerson('小明',20); 特征：解决了创建多个相似对象问题，但却没有解决对象识别的问题，即怎样知道这个对象的类型。 构造函数模式ECMAScript中的构造函数可以用来创建特定类型的对象，且构造函数始终都应以大写开头，例如将上面的例子重写如下123456789function Person(name,age)&#123; this.name=name; this.age=age; this.sayName=function()&#123; console.log(this.name); &#125;&#125;var person=new Person('小明',21); 相比构造函数： 没有显试的创建对象 直接将属性和方法赋给了this对象 没有return语句 胜于工厂模式之处在于，可以区分对象类型，如下：123console.log(person.constructor==Person); //trueconsole.log(person instanceof Object); //trueconsole.log(person instanceof Person); //true 这里之所以是Object的实例，是因为所有对象均继承自Object 将构造函数当做函数既然构造函数也是个函数，那他就可一当做一个普通函数来调用,如下：123456//当做构造函数使用var person=new Person('小明',21);person.sayName()//小明//当做普通函数使用Person('小华',20);window.sayName()//小明 在这里调用函数this始终指向Global对象 构造函数的问题构造函数的主要问题在于每个方法都要在实例上重新创建一遍。上面例子中的sayName()方法在实例化时都要重新创建一遍，如下：123var person1=new Person('小明',21);var person2=new Person('小华',21);console.log(person1.sayName == person2.sayName); //false 为了解决这种问题我们可以使用下面的方式原型模式。 原型模式我们创建的每一个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法。简单的来说使用它可以让所有对象实例共享它所包含的属性和方法。如下面的例子：1234567891011121314function Person()&#123;&#125;Person.prototype.name="小明";Person.prototype.age=20;Person.prototype.sayName=function()&#123; console.log(this.name);&#125;var person1=new Person();person1.sayName() //小明var person2=new Person();person2.sayName() //小明console.log(person1.sayName === person2.sayName); //true 理解原型对象在默认情况下所有原型对象都会自动化获得一个constructor(构造函数)属性，这个属性是指向原型所在函数的指针。各个对象之间的关系:当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，即阻止我们访问，但并不会修改这个属性，例如：1234567891011121314function Person()&#123;&#125;Person.prototype.name="小明";Person.prototype.age=20;Person.prototype.sayName=function()&#123; console.log(this.name);&#125;var person=new Person();person.name="jack";console.log(person.name); //Jack 来自实例delete person.name;console.log(person.name); //小明 来自原型 更简单的原型语法为了从视觉上更好的封装原型的功能和减少不必要的输入，最常见的做法如下面的例子：12345678function Person()&#123;&#125;;Person.prototype=&#123; name:"小明", age:20, sayName : function()&#123; console.log(this.name); &#125;&#125; 这样创建本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor 属性（指向Object构造函数），如下所示：1234var person=new Person()console.log(person instanceof Person); //trueconsole.log(person.constructor == Object); //trueconsole.log(person.constructor == Person); //false 如果constructor真的非常重要，可以向下面这样做：12345678910function Person()&#123;&#125;;Person.prototype=&#123; //手动将值设为Person 但会导致他的[[Enumerable]]为true constructor:Person, name:"小明", age:20, sayName : function()&#123; console.log(this.name); &#125;&#125; 原型的动态性重写原型会切断所有原型与任何之前已经存在的对象实例之间的联系，例如：123456789101112function person()&#123;&#125;var friend=new Person();Person.prototype=&#123; constructor:Person, name:"小明", age:20, sayName : function()&#123; console.log(this.name); &#125;&#125;friend.sayName(); //undefined 下图显示了整个过程: 组合使用构造函数模式和原型模式如果单独使用原型对象，实例就没有了自己的属性，所以我们需要组合使用构造函数模式与原型模式，同时包含了两种花模式的长处，重写以前的例子如下：123456789101112131415161718192021function Person(name,age)&#123; this.name=name; this.age=age; this.friends=['小林','小华'];&#125;Person.prototype=&#123; constructor:Person, sayName : function()&#123; console.log(this.name); &#125;&#125;var person1=new Person('小明',21);var person2=new Person('小黑',20);person1.friends.push('王尼玛');console.log(person1.friends); //["小林", "小华", "王尼玛"]console.log(person2.friends); //["小林", "小华"]console.log(person1.friends === person2.friends); //falseconsole.log(person1.sayName === person2.sayName); //true 这种构造函数与原型模式混成的模式，是目前使用最广泛的、认同最高的一种创建自定义类型的方法 动态原型模式这种方式把所有信息都封装在了构造函数中，在必要的情况下去初始化原型，如下例子，只有在sayName()不存在的情况下才会初始化原型中的方法。1234567891011121314function Person(name,age)&#123; //属性 this.name=name; this.age=age; //方法 if(typeof this.sayName != 'function')&#123; Person.prototype.sayName=function()&#123; console.log(this.name); &#125; &#125;&#125;var person=new Person('小明',21);person.sayName(); 寄生构造函数模式这和工厂模式写法有点相似，但仔细观察就会发现，是完全不一样的。有点像继承 ，继承Object类1234567891011function Person(name,age)&#123; var o=new Object(); o.name=name; o.age=age; o.sayName=function()&#123; console.log(this.name); &#125; return o;&#125;var person=new Person('小明',20); 我们建议在可以使用其他模式的情况下，尽量不要使用此种方法 稳妥构造函数模式如下例，在这种方式除了使用sayName方法外，没有其他方法可以访问到name属性。它非常适合在某些安全环境执行1234567891011121314function Person(name,age)&#123; //要返回的对象 var o=new Object(); //在这里定义私有变量和函数 //添加方法 o.sayName=function()&#123; console.log(name); &#125; //返回对象 return o;&#125;var person=new Person('小明',20);person.sayName();//小明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS对象访问器属性]]></title>
      <url>%2F2016%2F11%2F22%2Fjs-ObjectdefineProperty%2F</url>
      <content type="text"><![CDATA[访问器属性不包含数据值，他们包含一对getter和setter函数（但都不是必须的），在读取访问器属性时会调用getter函数，在写入是会调用setter函数。 定义一个访问器属性123456789101112131415161718var book=&#123; _year:2004,//定义数据属性 edition:1&#125;//定义访问器属性Object.defineProperty(book,'year',&#123; get:function()&#123; return this._year; &#125;, set:function(value)&#123; this.edition=value-this._year; this._year=value; &#125;&#125;)book.year=2006;console.log(book.edition);//2 定义多个属性:1234567891011121314151617181920var book=&#123;&#125;Object.defineProperties(book,&#123; _year:&#123; //定义数据属性 value:2004 &#125;, edition:&#123; value:1 &#125;, //定义访问器属性 year:&#123; get:function()&#123; return this._year; &#125;, set:function(value)&#123; this.edition=value-this._year; this._year=value; &#125; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS的Function类型]]></title>
      <url>%2F2016%2F11%2F21%2Fjs-create-function%2F</url>
      <content type="text"><![CDATA[每一个函数都是Function类型的事例，也就是每一个函数都是对象，而函数名就是只想这个对象的指针。 定义函数的三种方式第一种方法是在其他语言中比较常见的方法。(函数声明) 123function sum(num1,num2)&#123; return num1+num2;&#125; 第二种定义了一个变量sum并将其初始化为一个函数，想申明其他变量一样末尾也要加上分号。(函数表达式)123var sum=function(num1,num2)&#123; return num1+num2;&#125;; 第三种是使用Function构造函数，Function构造函数可以接受任意数量的参数，最后一个参数始终被看成参数体。1var sum=new Function("num1","num2","return num1+num2"); 由于函数名仅仅是指向函数的指针，所以一个函数可能有多个名字，如下面的例子：1234567console.log(sum(10,10));//20var anotherSum=sum();console.log(anotherSum(10,10));//20sum=null;console.log(anotherSum(10,10));//20 没有重载由上面的内容，我们知道函数名仅仅是一个指向函数的指针，所以我们可以很容易的理解下面的例子：1234567function add(num)&#123; return num+1;&#125;function add(num)&#123; return num+2;&#125;console.log(add(1));//3 可以看出后面的函数覆盖了前面的函数，即覆盖了第引用的一个还是函数的变量add。 函数声明与函数表达式函数申明与函数表达式其实并不是完全一样的，在解析器向执行环境加载数据时，解析器会率先读取函数声明(一个名为函数名提升的过程)，并使其在执行任何代码前可以访问。以下两个例子说明了两者之间的区别：1234console.log(sum(10,10));//20function sum(num1,num2)&#123; return num1+num2;&#125; 以下代码有与第一行代码会导致unexpected identifier(意外标识符)错误，实际也不会执行到下一行1234console.log(sum(10,10));//20var sum=function(num1,num2)&#123; return num1+num2;&#125; 作为值的函数由于函数本身就是变量，所以可以从一个函数中返回另一个对象，这其实是一种极为有用的技术。例如假设有一个对象数组，我们要根据某个对象属性进行排序，就可以利用这个技术来实现如下：12345678910111213141516function sortData(propertyName)&#123; return function(obj1,obj2)&#123; var v1=obj1[propertyName]; var v2=obj2[propertyName]; if(v1&lt;v2) return -1; else if(v1&gt;v2) return 1; else return 0; &#125;;&#125;var data=[&#123;name:"小明",age:29&#125;,&#123;name:"小华",age:21&#125;];data.sort(sortData('age'));console.log(data[0].name);//小华 在默认情况下，sort()方法会调用每个对象的toString()方法以确定他们的次序，但得到的结果往往并不尽如人意，所以我们调用sortData(propertyName)创建了一个比较函数，一遍按照每个对象的age 属性排序。 函数的内部属性在函数内部有两个特殊的对象arguments和this，ECMAScript5规范了另一个函数对象属性caller。 arguments其中arguments是一个数组类对象，包含传入函数中的所有参数。虽然arguments的主要作用是保存函数参数，但他还有一个叫callee的属性，该属性是一个指向拥有arguments的函数的指针。利用这个属性可以解除紧密耦合的现象，如下面这个阶乘函数：12345function factorial(num)&#123; if(num&lt;=1) return 1; else return num*factorial(num-1);&#125; 在这个函数中函数的执行与函数的factorial紧紧的耦合在了一起，为了消除这种紧密的耦合现象，可以向下面这样使用arguments.callee:12345function factorial(num)&#123; if(num&lt;=1) return 1; else return num*arguments.callee(num-1);&#125; 这样无论引用函数时使用的是什么名字，都可以保证正常完成递归调用，例如:123456var trueFactorial=factorial;factorial=function()&#123; return 0;&#125;console.log(trueFactorial(5));//120console.log(factorial);//0 thisthis引用的是函数执行环境的对象，当在网页的全局作用域中调用函数this对象引用的就是window对象。12345678910window.color="red";var o=&#123; color:'blue'&#125;function sayColor()&#123; console.log(this.color);&#125;sayColor()//redo.sayColor=sayColor();o.sayColor()//blue 由上面的例子我们可以看出当在全局作用域中调用sayColor()时this引用的是全局对象window,在把函数赋值给对象o并调用是this 引用的对象o。这里要注意的是全局的sayColor函数与o.sayColor()指向的任然是同一个函数 callercaller是调用当前函数的函数的引用，例如：1234567function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller);//这里输出outer()函数的源代码 //为了实现更松散的耦合可以写作arguments.callee.caller&#125; 在严格模式下运行时，访问arguments.callee会导致错误 call()和apply()每个函数包括两个非继承而来的方法：call()和apply()，这两个函数的作用都是在特定的作用域中调用函数，等于设置函数体内的this值。apply接受两个参数，第一个参数是运行函数的作用域，另一个是参数数组。例如：1234567function sum(num1,num2)&#123; return num1+num2;&#125;function callSum(num1,num2)&#123; return sum.apply(this,arguments)//arguments也可以写成[num1,num2]&#125;console.log(callSum(10,10));//20 call()函数与apply()在于接收参数的不同，call()除了第一个参数this外 ,传递给函数的参数必须逐个举例出来，例如：1234567function sum(num1,num2)&#123; return num1+num2;&#125;function callSum(num1,num2)&#123; return sum.call(this,num1,num2)&#125;console.log(callSum(10,10));//20 他们真正强大的地方是扩充函数的作用域，例如：12345678window.color="red";var o=&#123;color:'blue'&#125;;function sayColor()&#123; console.log(color);&#125;sayColor.call(this) //redsayColor.call(o); //blue 使用这种方法来扩充作用于最大的好处在于对象不需要与方法有任何的耦合关系。 ECMAScript5还定义了一个方法：bind()这个方法会创建一个实例，其this值指向传给他的函数值，例如：1234567window.color="red";var o=&#123;color:'blue'&#125;;function sayColor()&#123; console.log(color);&#125;var oSayColor=sayColor.bind(o);oSayColor(); //blue]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中没有块级作用域]]></title>
      <url>%2F2016%2F11%2F17%2Fjs-kuaijizuoyongyu%2F</url>
      <content type="text"><![CDATA[在其他类C语言中由花括号封闭的代码块都有自己的作用域，而JavaScript则没有块级作用域。 如下代码所示，在JavaScript中并不会得到想要的答案。1234if(true)&#123; var color="blue";&#125;console.log(color);//blue 在JavaScript中，if语句中的变量声明会添加到当前的执行环境（在这里是全局环境）中，在使用for语句时要牢记这一差异，例如： 1234for (var i = 0; i &lt; 10; i++) &#123; //todo&#125;console.log(i);//10 声明变量使用var声明变量时，变量会自动添加到最接近的环境中。在函数内部最接近的环境就是函数的局部环境。 如果初始化变量时没有使用var声明，该变量会自动添加到全局环境。如下所示123456function add(num1,num2)&#123; var sum=num1+num2; return sum;&#125;console.log(add(1,2));//3console.log(sum);//由于sum不是有效的变量，由此会导致错误 如果省略var声明，执行add()之后，sum也将可以访问，如下所示123456function add(num1,num2)&#123; sum=num1+num2; return sum;&#125;console.log(add(1,2));//3console.log(sum);//3 通常在编写JavaScript代码中，我们建议在初始化变量前一定要声明，否则可能会导致意外 查询标识符当在某个环境中为了读取或写入而引入一个标示符时，必须通过搜索来确定此标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询。 下面这个例子，可以展现查询标识符的过程:1234567var color="blue";function getColor()&#123; var color='red'; return color;&#125;console.log(getColor());//redconsole.log(color);//blue 很明显从中可以看出访问局部变量要比访问全局变量快]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中基本类型和引用类型]]></title>
      <url>%2F2016%2F11%2F16%2F1611161%2F</url>
      <content type="text"><![CDATA[基本类型值指的是简单的数据段 引用类型值指那些可能由多个值的构成的对象。 动态属性基本类型我们不能给基本类型的值添加属性。123var person;person.name="Jack";logconsole.log(person.name);//undefined 引用类型可以添加、改变、删除引用类型的属性。123var person=new object();person.name="Jack";console.log(person.name); //Jack 复制变量值基本类型复制基本类型的值时，会在变量对象上创建一个新的值，然后把该值复制到为新变量分配的位置上。123var num1=5;var num2=num1;console.log(num2);//5 引用类型复制引用类型的值时与基本类型一样，不同的是复制的新值实际上是一个指针，而这个指针指向存储在堆中的对象。 如下面例子所示连个变量其实将引用同一个对象：1234var obj1=new Object();var obj2=obj1;obj2.name="Jack";console.log(obj1.name);//Jack 传递参数基本类型在传递基本类型时，传递的值会被赋值给一个局部变量。12345var person=new Object();function setName(obj)&#123; obj.name="Jack";&#125;console.log(person.name);//Jack 引用类型如下所示，变量被传递到setName()之后就被复制给了obj，在函数内部obj和person引用的是同一个对象，即是说这个变量是按值传递的，obj也会按引用来访问同一对象。12345var person=new Object();function setName(obj)&#123; obj.name="Jack";&#125;console.log(person.name);//Jack 由下面的例子我们可以看到，如果person是按引用传递的，那么输出的应该是’Greg’。这说明即是在函数内部修改了参数的值，但原始的引用任然未变。实际上在函数内部重写obj时，这个变量引用的就是一个局部对象了。1234567var person=new Object();function setName(obj)&#123; obj.name="Jack"; obj=new Object(); obj.name="Greg";&#125;console.log(person.name);//Jack]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[误删mysql数据之后 ，恢复数据的的方法]]></title>
      <url>%2F2016%2F11%2F13%2FrecoverMysqlData%2F</url>
      <content type="text"><![CDATA[利用mysql的二进制日志记录文件来恢复数据 就在昨天我在修改线上数据库字段的时候 ，改了一个不合适的字段长度，导致数据丢失，我立马关闭了网站，开始恢复数据。期初很慌张，以前没遇到过这种问题 。后来慢慢爬文，知道可以利用数据库二进制日志文件来恢复数据。于是我利用PHP来解析二进制文件找回了数据。 开启二进制日志记录文件 所幸数据库默认开启了二进制日志记录文件，不然我的数据全没了，损失很大，如果没开启可以用以下方式开启： 编辑my.cnf，添加: 1log-bin=/var/log/mysql/mysql-bin.log 开启日志后需要myssqladmin flush logs才能生效。 需要注意的是log-bin指定扩展名是无效的，当mysql创建二进制日志文件时，首先创建一个以“mysql_log_bin”为名称，以“.index”为后缀的文件；再创建一个以“mysql_log_bin”为名称，以 ‘.000001’为后缀的文件。当mysql服务重新启动一次以“.000001”为后缀的文件会增加一个，并且后缀名加1递增；如果日志长度超过了 max_binlog_size的上限（默认是1G）也会创建一个新的日志文件；使用flush logs（mysql命令符）或者执行mysqladmin –u –p flush-logs（windows命令提示符）也会创建一个新的日志文件。 解析二进制文件中的sql语句首先找到二进制文件，打开后会发现里面有很多SQL语句，但是很乱，有插入语句，跟新语句，还有一些其他日志记录的标志，在这里我只需要插入到order表中的数据 ，所以以此为例，编写php来解析我需要的sql插入语句。123456function getSql()&#123; $s = preg_quote(“INSERT INTO order (price,type,uid,info,subtime) VALUES (“); $str= file_get_contents('/usr/data/mysql-bin.000013'); preg_match_all('/\&#123;.*?\&#125;/',$str,$arr); return $arr[0];&#125; 执行这个函数返回一个数组，这个数组里面就是二进制文件中所有向order表中插入数据的SQL语句。然后在循环执行数组中的SQL语句至此所有数据就恢复了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[thinkPHP整合微信公众号支付]]></title>
      <url>%2F2016%2F11%2F13%2FthinkphpWeixinPay%2F</url>
      <content type="text"><![CDATA[给thinkphp添加扩展实现微信支付，基于官方微信支付的Demo开发 些此篇文章的原因主要是最近在做有关微信支付的开发，由于初次开发走了很多弯路，所以整理了一下写下这篇文章，参考文章thinkphp整合系列之微信公众号支付（来自白俊遥博客http://baijunyao.com）由于他的源码有点问题，所以我做了一些修改，整个项目我也fork过来了。 项目地址：http://git.oschina.net/crazy_boy/thinkphp-bjyadmin ，里面整合了很多扩展都可以参考。 由于大致用法原文里面都有，一下写一些原文中没有讲清楚或没有讲到的东西。 配置项/Application/Common/Conf/config.php源码如下：1234567'WEIXINPAY_CONFIG' =&gt; array( 'APPID' =&gt; '', // 微信支付APPID 'MCHID' =&gt; '', // 微信支付MCHID 商户收款账号 'KEY' =&gt; '', // 微信支付KEY 'APPSECRET' =&gt; '', // 公众帐号secert (公众号支付专用) 'NOTIFY_URL' =&gt; 'http://域名/Home/Weixinpay/notify', // 接收支付状态的连接 ), 其中NITIFY_URL是支付成功后微信返回支付结果的一个连接，在我的测试中，只有在支付成功后微信才会向此链接放回结果，其中要特别注意的一点是此链接不能带有任何的参数，如这种连接是不行的:http://域名/index.php/Home/Weixinpay/notify。 微信支付key需要在微信商户平台中设置。（账户中心-&gt;API安全） 异步接收通知这个讲到的就是上面提到的notify_url，源码如下，由于是微信异步请求的链接，所以切记不要用session来操作，因为他是访问不了的，微信会放回订单号out_trade_no。123456789public function notify()&#123; // 导入微信支付sdk Vendor('Weixinpay.Weixinpay'); $wxpay=new \Weixinpay(); $result=$wxpay-&gt;notify(); if ($result) &#123; // 验证成功 修改数据库的订单状态等 $result['out_trade_no']为订单id &#125;&#125; 订单号$out_trade_no这个订单号是由你自己来生成的，官方推荐的方式是时间+字符串的方式，time()+uid，即当前时间+用户id这是我的做法。生成好之后直接生成订单并存入数据库，下面是我的源码:12345678910111213public function js()&#123; // 此处根据实际业务情况生成订单 然后拿着订单去支付 // 用时间戳虚拟一个订单号 （请根据实际业务更改） session('total_fee',I('get.total_fee')); $order['id']=$out_trade_no; $order['uid']=session('id'); $order['amount']=I('get.total_fee'); M('order')-&gt;add($order); // 组合url $url=U('Wx/pay',array('out_trade_no'=&gt;$out_trade_no)); // 前往支付 $this-&gt;redirect($url);&#125; 之后修改/ThinkPHP/Library/Vendor/Weixinpay/Weixinpay.php 的170行，用获得的订单号查询订单信息，并传入，源码如下：123456789$order=M('order')-&gt;find($out_trade_no);$order=array( 'body'=&gt;“充值”.$order['amount'].'元',// 商品描述（需要根据自己的业务修改 'total_fee'=&gt;$order['amount']*100,// 订单金额 以(分)为单位（需要根据自己的业务修改 'out_trade_no'=&gt;$out_trade_no,// 订单号（需要根据自己的业务修改） 'product_id'=&gt;'1',// 商品id（需要根据自己的业务修改） 'trade_type'=&gt;'JSAPI',// JSAPI公众号支付 'openid'=&gt;$openid// 获取到的openid); html配合使用html的配合：/tpl/Home/Weixinpay/pay.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;充值&lt;/title&gt;&lt;/head&gt;&lt;body style="text-align: center;"&gt; &lt;div class="header"&gt; &lt;div class="all_w "&gt; &lt;div class="ttwenz"&gt; &lt;h4&gt;确认交易&lt;/h4&gt; &lt;h5&gt;微信安全支付&lt;/h5&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="wenx_xx"&gt; &lt;div class="mz"&gt;充值&lt;/div&gt; &lt;div class="wxzf_price"&gt;￥&#123;:session("total_fee")&#125;&lt;/div&gt;&lt;/div&gt;&lt;div class="skf_xinf"&gt; &lt;div class="all_w"&gt; &lt;span class="bt"&gt;收款方&lt;/span&gt; &lt;span class="fr"&gt;商家名字&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;a onclick="pay()" class="ljzf_but all_w"&gt;确认支付&lt;/a&gt;&lt;script&gt;function onBridgeReady()&#123; var data=&#123;$data&#125;; WeixinJSBridge.invoke( 'getBrandWCPayRequest', data, function(res)&#123; if(res.err_msg == "get_brand_wcpay_request:ok" ) &#123; alert('支付成功!'); &#125;else&#123; alert('支付失败!'); &#125; history.go(-1); &#125; );&#125;function pay()&#123; if (typeof WeixinJSBridge == "undefined")&#123; if( document.addEventListener )&#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); &#125;else if (document.attachEvent)&#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); &#125; &#125;else&#123; onBridgeReady(); &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设置Apache，实现一个空间多个域名]]></title>
      <url>%2F2016%2F11%2F13%2FsetApacheConfig%2F</url>
      <content type="text"><![CDATA[此方法利用apache的mod_rewrite模块，实现修改map文件添加域名且不用重启Apache 步骤如下 去除httpd.conf文件中#LoadModule rewrite_module modules/mod_rewrite.so前面的”#”号; 然后再在httpd.conf最后书写如下规则： 12345RewriteEngine onRewriteMap lowercase int:tolowerRewriteMap vhost txt:/usr/local/etc/apache/vhost.mapRewriteCond $&#123;lowercase:%&#123;SERVER_NAME&#125;&#125; ^(.+)$RewriteCond $&#123;vhost:%1&#125; ^(/.)$ \r\nRewriteRule ^/(.)$ %1/$1 其中的 /usr/local/etc/apache 是你的 apache 服务器配置文件所在路径，根据实际情况更改（例如在/etc/httpd/下面）。然后，在这个所在路径的目录下创建一个文件： vhost.map，内容格式为： 12#你需要添加的域名 网站路径blog.muzishg.com /usr/local/apache/htdocs/blog 最后重启Apache服务器，之后需要再添加域名时只需要修改vhost.map文件，无需重启Apache，所有域名只需解析一条a记录到该服务器的外网IP上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[生活]]></title>
      <url>%2F2016%2F11%2F13%2F%E7%94%9F%E6%B4%BB%2F</url>
      <content type="text"><![CDATA[生活不止眼前的苟且，还有诗和远方 生命在于折腾折腾来折腾去，又用hexo在github上重新建了这个博客，希望自己坚持下去吧。]]></content>
    </entry>

    
  
  
</search>
